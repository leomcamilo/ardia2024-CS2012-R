length(unique(TelecomUsers$customerID))
TelecomUsers %>% group_by(Contract)
ByContract <- TelecomUsers %>% group_by(Contract)
View(ByContract)
chicago <- mutate(chicago, year = as.POSIXlt(date)$year + 1900)
TelecomUsers$TotalCharges %>% select(NA)
TelecomUsers$TotalCharges %>% select(is.na())
TelecomUsers$TotalCharges %>% filter(is.na())
TelecomUsers %>% filter(TotalCharges == NA)
filter(TelecomUsers, TotalCharges == NA)
select(TelecomUsers, TotalCharges == NA)
select(TelecomUsers$TotalCharges, NA)
select(TelecomUsers$TotalCharges, "NA")
summary(TelecomUsers$MonthlyCharges)
summary(TelecomUsers$TotalCharges)
length(na.omit(TelecomUsers$TotalCharges))
length(TelecomUsers$TotalCharges)
str(TelecomUsers$tenure)
filter(TelecomUsers, tenure = 0)
filter(TelecomUsers, tenure == 0)
length(filter(TelecomUsers, tenure == 0))
length(filter(TelecomUsers$tenure, tenure == 0))
str(TelecomUsers$tenure)
filter(TelecomUsers, tenure == 0)
sum(is.na(unique(TelecomUsers$MonthlyCharges)))
sum(is.na(unique(TelecomUsers$TotalCharges)))
str(TelecomUsers$tenure)
filter(TelecomUsers, tenure == 0)
filter(TelecomUsers, tenure == 0)
select(filter(TelecomUsers, PaperlessBilling == "No"),PaperlessBilling:PaymentMethod)
unique(select(filter(TelecomUsers, PaperlessBilling == "No"),PaperlessBilling:PaymentMethod))
unique(select(filter(TelecomUsers, PaperlessBilling == "YES"),PaperlessBilling:PaymentMethod))
unique(select(filter(TelecomUsers, PaperlessBilling == "Yes"),PaperlessBilling:PaymentMethod))
ggplot(data = TelecomUsers) +
geom_bar(mapping = aes(PaymentMethod))
ggplot(data = TelecomUsers) +
geom_bar(mapping = aes(PaymentMethod))
ggplot(data = TelecomUsers) +
geom_bar(mapping = aes(MonthlyCharges))
ggplot(data = TelecomUsers) +
geom_boxplot(mapping = aes(MonthlyCharges))
ggplot(data = TelecomUsers) +
geom_boxplot(mapping = aes(y = MonthlyCharges))
ggplot(data = TelecomUsers) +
geom_point(mapping = aes(x = MonthlyCharges))
ggplot(data = TelecomUsers) +
geom_point(mapping = aes(MonthlyCharges))
ggplot(data = TelecomUsers) +
geom_point(mapping = aes(x = MonthlyCharges, y = count(customerID)))
ggplot(data = TelecomUsers) +
geom_point(mapping = aes(x = MonthlyCharges, y = Churn))
ggplot(data = TelecomUsers, mapping = aes(y = MonthlyCharges)) +
geom_boxplot()
ggplot(data = TelecomUsers, mapping = aes(y = TotalCharges)) +
geom_boxplot()
ggplot(data = TelecomUsers, mapping = aes(y = MonthlyCharges)) +
geom_boxplot()
ggplot(data = TelecomUsers, mapping = aes(x = tenure, y = MonthlyCharges)) +
geom_bar()
ggplot(data = TelecomUsers) +
geom_bar(mapping = aes(x = tenure, y = MonthlyCharges))
ggplot(data = TelecomUsers) +
geom_point(mapping = aes(x = tenure, y = MonthlyCharges))
ggplot(data = TelecomUsers) +
geom_point(mapping = aes(x = tenure, y = MonthlyCharges, color = Contract))
ggplot(data = TelecomUsers) +
geom_point(mapping = aes(x = tenure, y = MonthlyCharges, color = Contract)) +
scale_color_manual(values = c("#5548D8","#D84855","#48D855"))
ggplot(data = TelecomUsers) +
geom_point(mapping = aes(x = tenure, y = MonthlyCharges, color = Contract)) +
scale_color_manual(values = c("#D84855","#48D855","#5548D8"))
ggplot(data = TelecomUsers) +
geom_point(mapping = aes(x = tenure, y = MonthlyCharges, color = Contract)) +
scale_color_manual(values = c("#D84855","#38D835","#5548D8"))
ggplot(data = TelecomUsers) +
geom_point(mapping = aes(x = tenure, y = MonthlyCharges, color = Contract)) +
scale_color_manual(values = c("#D84855","#18D815","#5548D8"))
ggplot(data = TelecomUsers) +
geom_point(mapping = aes(x = tenure, y = MonthlyCharges, color = Contract)) +
scale_color_manual(values = c("#D84855","#18E815","#5548D8"))
ggplot(data = TelecomUsers) +
geom_point(mapping = aes(x = tenure, y = MonthlyCharges, color = Contract)) +
scale_color_manual(values = c("#D84855","#38D825","#5548D8"))
str(TelecomUsers$tenure)
filter(TelecomUsers, tenure == 0)
summary(TelecomUsers$MonthlyCharges)
summary(TelecomUsers$TotalCharges)
summary(TelecomUsers$MonthlyCharges)
summary(TelecomUsers$TotalCharges)
ggplot(data = TelecomUsers) +
geom_bar(mapping = aes(x = SeniorCitizen, y = MonthlyCharges, color = Churn))
ggplot(data = TelecomUsers, mapping = aes(x = SeniorCitizen, y = MonthlyCharges, color = Churn)) +
geom_bar()
ggplot(data = TelecomUsers, mapping = aes(x = MonthlyCharges, color = Churn)) +
geom_bar()
ggplot(data = TelecomUsers, mapping = aes(x = MonthlyCharges, color = Partner)) +
geom_bar()
ggplot(data = TelecomUsers, mapping = aes(x = MonthlyCharges, color = Dependents)) +
geom_bar()
ggplot(data = TelecomUsers, mapping = aes(x = MonthlyCharges, color = MultipleLines)) +
geom_bar()
ggplot(data = TelecomUsers, mapping = aes(x = MonthlyCharges, fill = MultipleLines)) +
geom_bar()
ggplot(data = TelecomUsers, mapping = aes(x = MonthlyCharges, color = MultipleLines)) +
geom_bar()
ggplot(data = TelecomUsers, mapping = aes(x = MonthlyCharges, color = InternetService)) +
geom_bar()
ggplot(data = TelecomUsers, mapping = aes(x = MonthlyCharges, color = PhoneService)) +
geom_bar()
ggplot(data = TelecomUsers, mapping = aes(x = MonthlyCharges, color = InternetService)) +
geom_bar()
ggplot(data = TelecomUsers, mapping = aes(x = MonthlyCharges, color = InternetService)) +
geom_bar()
ggplot(data = filter(TelecomUsers, churn == "Yes"), mapping = aes(x = MonthlyCharges, color = InternetService)) +
geom_bar()
ggplot(data = filter(TelecomUsers, Churn == "Yes"), mapping = aes(x = MonthlyCharges, color = InternetService)) +
geom_bar()
ggplot(data = filter(TelecomUsers, Churn == "No"), mapping = aes(x = MonthlyCharges, color = InternetService)) +
geom_bar()
ggplot(data = filter(TelecomUsers, Churn == "Yes"), mapping = aes(x = MonthlyCharges, color = PhoneService)) +
geom_bar()
ggplot(data = filter(TelecomUsers, Churn == "No"), mapping = aes(x = MonthlyCharges, color = PhoneService)) +
geom_bar()
ggplot(data = filter(TelecomUsers, Churn == "Yes"), mapping = aes(x = MonthlyCharges, color = InternetService)) +
geom_bar()
ggplot(data = filter(TelecomUsers, Churn == "No"), mapping = aes(x = MonthlyCharges, color = InternetService)) +
geom_bar()
ggplot(data = TelecomUsers) +
geom_point(mapping = aes(x = tenure, y = MonthlyCharges, color = PaymentMethod))
#scale_color_manual(values = c("#D84855","#38D825","#5548D8"))
View(TelecomUsers)
if(!require(datasets)){
install.packages("datasets")
library(datasets)
}
library(datasets)
telecomdata <- read.table("TelecomUsers.csv", sep = ";", header = TRUE)
write.csv(TelecomUsers, file = "TelecomUsers.csv", sep = ",")
install.packages("caret")
factorial(3)
factorial
install.packages("installr")
install.packages("rtools")
install.packages("installr")
numerico
numerico <- 1
caracter <- "estudantes"
View(who)
View(df_sep)
View(df)
suppressMessages(library(tidyverse))
suppressMessages(library(lubridate))
suppressMessages(library(readxl))
suppressMessages(library(highcharter))
suppressMessages(library(tidyquant))
suppressMessages(library(tibbletime))
suppressMessages(library(quantmod))
suppressMessages(library(PerformanceAnalytics))
suppressMessages(library(scales))
suppressMessages(library(timetk))
symbols <- c("SPY","EFA", "IJS", "EEM","AGG")
prices <-
getSymbols(symbols,
src = 'yahoo',
from = "2012-12-31",
to = "2017-12-31",
auto.assign = TRUE,
warnings = FALSE,) %>%
map(~Ad(get(.))) %>%
reduce(merge) %>%
`colnames<-`(symbols)
#to monthly prices
prices_monthly<-prices %>%
to.monthly(indexAt = "lastof", OHLC = FALSE)
#computing returns
asset_monthly_returns_xts <-
Return.calculate(prices_monthly,
method = "discrete") %>%
na.omit()
head(asset_monthly_returns_xts,3)
install.packages("GetHFData")
install.packages("quantmod")
library(quantmod)
install.packages("tidyverse")
install.packages("tidyquant")
install.packages("dplyr")
install.packages("readxl")
install.packages("lubridate")
install.packages("zoo")
install.packages("zoo")
install.packages("PerformanceAnalytics")
install.packages("PerformanceAnalytics")
install.packages("rmarkdown")
install.packages("webshot2")
install.packages("here")
install.packages("GetHFData")
library(quantmod)
install.packages("Quandl")
install.packages("flexdashboard")
install.packages("readxl")
install.packages("tidyverse")
setwd("~/Bid-ask-dissertacao")
library(tidyverse)
library(quantmod)
library(readr)
company_codes <- read_csv("company_codes.csv")
View(company_codes)
library(readr)
company_codes <- read_csv("company_codes.csv")
# Baixando precos com Quantmod
getSymbols(company_codes$code, from = "2018-01-01", to = "2024-10-30", src = "yahoo")
View(company_codes)
library(readr)
company_codes <- read_csv("company_codes.csv")
# Baixando precos com Quantmod
getSymbols(company_codes$Company_Code, from = "2018-01-01", to = "2024-10-30", src = "yahoo")
View(VAMO3.SA)
View(VVEO3.SA)
View(SBFG3.SA)
install.packages("bidask")
View(SBFG3.SA)
dplyr::select(SBSP3.SA[1:4])
SBSP3.SA[1:4]
SBSP3.SA[,1:4]
nrow(SBSP3.SA[,1:4])
bidask::spread(SBSP3.SA[,1:4], method = "EDGE", width = nrow(SBSP3.SA[,1:4]), na.rm = TRUE)
bidask::spread(SBSP3.SA[,1:4], method = "EDGE", width = 21, na.rm = TRUE)
plot(bidask::spread(SBSP3.SA[,1:4], method = "EDGE", width = 21, na.rm = TRUE))
# Baixando precos com Quantmod
prices <- getSymbols(company_codes$Company_Code, from = "2018-01-01", to = "2024-10-30", src = "yahoo")
type(prices)
prices
company_codes <- read_csv("company_codes.csv")
# Baixando precos com Quantmod
prices <- getSymbols(company_codes$Company_Code, from = "2018-01-01", to = "2024-10-30", src = "yahoo")
company_codes <- read_csv("company_codes.csv")
# Baixando precos com Quantmod
prices <- getSymbols(company_codes$Company_Code, from = "2018-01-01", to = "2024-10-30", src = "yahoo")
# Calculando spread com Ardia e CS
# bidask::spread(SBSP3.SA[,1:4], method = "EDGE", width = 21, na.rm = TRUE)
company_codes <- read_csv("company_codes.csv")
# Função segura para baixar dados
safe_getSymbols <- safely(function(symbol) {
getSymbols(symbol, src = "yahoo", from = "2018-01-01", to = "2024-10-30", auto.assign = FALSE)
})
# Aplicar a função a todos os códigos de empresas usando purrr::map
company_data_list <- company_codes$Company_Code %>%
map(~ safe_getSymbols(.x))
# Extrair os resultados bem-sucedidos e Nomear a lista com os códigos das empresas
company_data_clean <- company_data_list %>%
map("result") %>%
set_names(company_codes$Company_Code)
# Verificar quais downloads falharam
errors <- company_data_list %>%
map("error") %>%
keep(~ !is.null(.x))
if (length(errors) > 0) {
print("Alguns downloads falharam:")
print(errors)
} else {
print("Todos os dados foram baixados com sucesso.")
}
View(company_data_clean)
company_data_clean[["ALOS3.SA"]]
str(company_data_clean)
# Calcular os spreads para cada empresa
company_spreads <- company_data_clean %>%
map(~ bidask::spread(.x[, 1:4], method = "EDGE", width = 21, na.rm = TRUE))
View(company_spreads)
company_spreads[["ALOS3.SA"]]
#Transformando num único dataframe
company_spreads_df <- company_spreads %>%
map_dfr(~ .x, .id = "Company_Code")
View(company_spreads_df)
#Transformando num único dataframe mantendo a data e o código da empresa
company_spreads_df <- company_spreads %>%
map_dfr(~ .x %>% mutate(Date = index(.x))) %>%
rename_all(~ str_replace(., "X", "Company_")) %>%
gather(key = "Company_Code", value = "Spread", -Date)
# Calcular o spread com method "CS" para cada empresa em company_spreads
company_spreads_CS <- company_data_clean %>%
map(~ bidask::spread(.x[, 1:4], method = "CS", width = 21, na.rm = TRUE))
View(company_spreads_CS)
company_spreads_CS[["AESB3.SA"]]
company_spreads_CS[["AESB3.SA"]]%>%View()
# Calcular os spreads para cada empresa
company_spreads_EDGE <- company_data_clean %>%
map(~ bidask::spread(.x[, 1:4], method = "EDGE", width = 21, na.rm = TRUE))
# Calcular o spread com method "CS" para cada empresa em company_spreads
company_spreads_CS <- company_data_clean %>%
map(~ bidask::spread(.x[, 1:4], method = "CS", width = 21, na.rm = TRUE))
# Juntar company_spreads e company_spreads_CS no mesmo dataframe com colunas de Data, Código, Spread_EDGE e Spread_CS
company_spreads_df <- map2_dfr(company_spreads_EDGE, company_spreads_CS, ~ {
data_frame(
Date = index(.x),
Spread_EDGE = .x,
Spread_CS = .y
)
}, .id = "Company_Code")
View(company_spreads_df)
View(company_data_list)
company_data_list[[3]]
# Importar códigos de empresas
company_codes <- read_csv("company_codes.csv")
# Função segura para baixar dados
safe_getSymbols <- safely(function(symbol) {
getSymbols(symbol, src = "yahoo", from = "2017-01-01", to = "2024-10-30", auto.assign = FALSE)
})
# Aplicar a função a todos os códigos de empresas usando purrr::map
company_data_list <- company_codes$Company_Code %>%
map(~ safe_getSymbols(.x))
# Extrair os resultados bem-sucedidos e Nomear a lista com os códigos das empresas
company_data_clean <- company_data_list %>%
map("result") %>%
set_names(company_codes$Company_Code)
# Verificar quais downloads falharam
errors <- company_data_list %>%
map("error") %>%
keep(~ !is.null(.x))
if (length(errors) > 0) {
print("Alguns downloads falharam:")
print(errors)
} else {
print("Todos os dados foram baixados com sucesso.")
}
# Calcular os spreads para cada empresa
company_spreads_EDGE <- company_data_clean %>%
map(~ bidask::spread(.x[, 1:4], method = "EDGE", width = 21, na.rm = TRUE))
# Calcular o spread com method "CS" para cada empresa em company_spreads
company_spreads_CS <- company_data_clean %>%
map(~ bidask::spread(.x[, 1:4], method = "CS", width = 21, na.rm = TRUE))
# Juntar company_spreads e company_spreads_CS no mesmo dataframe com colunas de Data, Código, Spread_EDGE e Spread_CS
company_spreads_df <- map2_dfr(company_spreads_EDGE, company_spreads_CS, ~ {
data_frame(
Date = index(.x),
Spread_EDGE = .x,
Spread_CS = .y
)
}, .id = "Company_Code")
# Calcular os spreads médios para cada ano em cada método e aplicar na variável company_spreads_year
company_spreads_year <- company_spreads_df %>%
mutate(Year = year(Date)) %>%
group_by(Company_Code, Year) %>%
summarise(
Spread_EDGE = mean(Spread_EDGE, na.rm = TRUE),
Spread_CS = mean(Spread_CS, na.rm = TRUE)
)
View(company_spreads_year)
# Agrupar as empresas com maiores médias de volume diários e selecionar os 30% maiores e 30% menores e os 40% restantes em 3 grupos diferentes
company_volumes <- company_data_clean %>%
map(~ Ad(get(.x), "Volume")) %>%
map_dbl(~ mean(.x, na.rm = TRUE))
View(company_data_clean)
company_data_clean[["ABCB4.SA"]]%>%View()
# Agrupar as empresas com maiores médias de volume diários e selecionar os 30% maiores e 30% menores e os 40% restantes em 3 grupos diferentes
# Calcular a média de volume para cada empresa
company_volumes <- company_data_clean %>%
# Extrair a coluna de Volume (coluna 5) de cada dataframe
map_dbl(~ mean(.x[[5]], na.rm = TRUE))
# Converter os resultados para um dataframe para melhor manipulação
company_volumes <- tibble(
Company = names(company_data_clean),
Mean_Volume = company_volumes
)
View(company_volumes)
# Agrupar as empresas com maiores médias de volume diários e selecionar os 30% maiores e 30% menores
# Calcular a média de volume para cada empresa
company_volumes <- company_data_clean %>%
# Extrair a coluna de Volume (coluna 5) de cada dataframe
map_dbl(~ mean(.x[[5]], na.rm = TRUE))
# Converter os resultados para um dataframe para melhor manipulação
company_volumes <- tibble(
Company = names(company_data_clean),
Mean_Volume = company_volumes
)
# Definir os percentis de 30% e 70%
volume_30 <- quantile(company_volumes_df$Mean_Volume, 0.3, na.rm = TRUE)
# Agrupar as empresas com maiores médias de volume diários e selecionar os 30% maiores e 30% menores
# Calcular a média de volume para cada empresa
company_volumes <- company_data_clean %>%
# Extrair a coluna de Volume (coluna 5) de cada dataframe
map_dbl(~ mean(.x[[5]], na.rm = TRUE))
# Converter os resultados para um dataframe para melhor manipulação
company_volumes <- tibble(
Company = names(company_data_clean),
Mean_Volume = company_volumes
)
# Definir os percentis de 30% e 70%
volume_30 <- quantile(company_volumes$Mean_Volume, 0.3, na.rm = TRUE)
volume_70 <- quantile(company_volumes$Mean_Volume, 0.7, na.rm = TRUE)
# Atribuir cada empresa a um grupo com base na média de volume
company_volumes <- company_volumes %>%
mutate(
Group = case_when(
Mean_Volume <= volume_30 ~ "Low Volume (Bottom 30%)",
Mean_Volume > volume_70 ~ "High Volume (Top 30%)",
TRUE ~ "Middle Volume (40%)"
)
)
# Empresas de baixo volume (Bottom 30%)
low_volume <- company_volumes %>%
filter(Group == "Low Volume (Bottom 30%)") %>%
pull(Company)
# Empresas de alto volume (Top 30%)
high_volume <- company_volumes %>%
filter(Group == "High Volume (Top 30%)") %>%
pull(Company)
View(company_volumes)
View(company_data_clean)
# Agrupar as empresas com maiores médias de volume diários e selecionar os 30% maiores e 30% menores
# Calcular a média de volume para cada empresa
company_volumes <- company_data_clean %>%
# Extrair a coluna de Volume (coluna 5) de cada dataframe
map_dbl(~ mean(.x[[5]], na.rm = TRUE))
# Converter os resultados para um dataframe para melhor manipulação
company_volumes <- tibble(
Company = names(company_data_clean),
Mean_Volume = company_volumes
)
# Definir os percentis de 30% e 70%
volume_30 <- quantile(company_volumes$Mean_Volume, 0.3, na.rm = TRUE)
volume_70 <- quantile(company_volumes$Mean_Volume, 0.7, na.rm = TRUE)
# Atribuir cada empresa a um grupo com base na média de volume
company_volumes <- company_volumes %>%
mutate(
Group = case_when(
Mean_Volume <= volume_30 ~ "Low Volume (Bottom 30%)",
Mean_Volume > volume_70 ~ "High Volume (Top 30%)",
TRUE ~ "Middle Volume (40%)"
)
)
# Empresas de baixo volume (Bottom 30%)
low_volume <- company_volumes %>%
filter(Group == "Low Volume (Bottom 30%)") %>%
pull(Company)
# Empresas de alto volume (Top 30%)
high_volume <- company_volumes %>%
filter(Group == "High Volume (Top 30%)") %>%
pull(Company)
# Criando um company_data_clean_high_volume e company_data_clean_low_volume
company_data_clean_high_volume <- company_data_clean[high_volume]
company_data_clean_low_volume <- company_data_clean[low_volume]
View(company_spreads_df)
# Agrupar as empresas com maiores médias de volume diários e selecionar os 30% maiores e 30% menores
# Calcular a média de volume para cada empresa
company_volumes <- company_data_clean %>%
# Extrair a coluna de Volume (coluna 5) de cada dataframe
map_dbl(~ mean(.x[[5]], na.rm = TRUE))
# Converter os resultados para um dataframe para melhor manipulação
company_volumes <- tibble(
Company = names(company_data_clean),
Mean_Volume = company_volumes
)
# Definir os percentis de 30% e 70%
volume_30 <- quantile(company_volumes$Mean_Volume, 0.3, na.rm = TRUE)
volume_70 <- quantile(company_volumes$Mean_Volume, 0.7, na.rm = TRUE)
# Atribuir cada empresa a um grupo com base na média de volume
company_volumes <- company_volumes %>%
mutate(
Group = case_when(
Mean_Volume <= volume_30 ~ "Low Volume (Bottom 30%)",
Mean_Volume > volume_70 ~ "High Volume (Top 30%)",
TRUE ~ "Middle Volume (40%)"
)
)
# Empresas de baixo volume (Bottom 30%)
low_volume <- company_volumes %>%
filter(Group == "Low Volume (Bottom 30%)") %>%
pull(Company)
# Empresas de alto volume (Top 30%)
high_volume <- company_volumes %>%
filter(Group == "High Volume (Top 30%)") %>%
pull(Company)
# Criando um company_data_clean_high_volume e company_data_clean_low_volume
company_data_clean_high_volume <- company_data_clean[high_volume]
company_data_clean_low_volume <- company_data_clean[low_volume]
# Calcular os spreads para cada empresa
company_spreads_EDGE <- company_data_clean %>%
map(~ bidask::spread(.x[, 1:4], method = "EDGE", width = 21, na.rm = TRUE))
# Calcular o spread com method "CS" para cada empresa em company_spreads
company_spreads_CS <- company_data_clean %>%
map(~ bidask::spread(.x[, 1:4], method = "CS", width = 21, na.rm = TRUE))
# Juntar company_spreads e company_spreads_CS no mesmo dataframe com colunas de Data, Código, Spread_EDGE e Spread_CS
company_spreads_df <- map2_dfr(company_spreads_EDGE, company_spreads_CS, ~ {
data_frame(
Date = index(.x),
Spread_EDGE = .x,
Spread_CS = .y
)
}, .id = "Company_Code")
# Calcular os spreads médios para cada ano em cada método e aplicar na variável company_spreads_year
company_spreads_year <- company_spreads_df %>%
mutate(Year = year(Date)) %>%
group_by(Company_Code, Year) %>%
summarise(
Spread_EDGE = mean(Spread_EDGE, na.rm = TRUE),
Spread_CS = mean(Spread_CS, na.rm = TRUE)
)
# Filtrar o company_spread_df para high_volume e low_volume
company_spreads_high_volume <- company_spreads_year %>%
filter(Company_Code %in% high_volume)
company_spreads_low_volume <- company_spreads_year %>%
filter(Company_Code %in% low_volume)
# Filtrar o company_spread_year para os anos de 2017 a 2019 (antes da pandemia), para 2020 e 2021 (durante a pandemia) e para 2022 a 2024 (após a pandemia)
company_spreads_pre <- company_spreads_year %>%
filter(Year %in% 2017:2019)
company_spreads_dur <- company_spreads_year %>%
filter(Year %in% 2020:2021)
company_spreads_pos <- company_spreads_year %>%
filter(Year %in% 2022:2024)
View(company_spreads_high_volume)
View(company_spreads_low_volume)
